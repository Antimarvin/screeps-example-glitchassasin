import { MinionTypes } from "Minions/minionTypes";

declare global {
    interface CreepMemory {
        objective?: string;
    }
}

export abstract class Objective {
    public id: string;
    constructor(public priority: number = 5) {
        this.id = this.constructor.name;
    }

    /**
     * Types of minions to assign
     */
    abstract minionTypes: MinionTypes[];

    /**
     * The BehaviorTree for all creeps (regardless of office)
     */
    abstract action: (creep: Creep) => void;

    /**
     * Called for each creep assigned. Objective should reduce creeps
     * to a summary for the calculation in meetsCapacity.
     */
    updateCapacity(creep: Creep) {};

    /**
     * Resets the summary generated by updateCapacity at the
     * beginning of the tick.
     */
    resetCapacity() {};

    /**
     * Should more minions be assigned to this objective, or
     * is its capacity met?
     */
    assign(creep: Creep) {
        if (!creep.spawning && this.minionTypes.includes(creep.memory.type)) {
            creep.memory.objective = this.id;
            return true;
        }
        return false;
    };
}
